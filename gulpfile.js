const browserSync = require('browser-sync').create('browserSync');
const _merge = require('lodash.merge');
const { series, parallel, watch } = require('gulp');
const path = require('path');
const yargs = require('yargs');

const generateDocumentation = require('./lib/documentation.js');
const { debugLog, jsonLog } = require('./lib/utils.js');

const defaultConfig = {
    src: {
        dir: 'src/',
        fonts: 'fonts/**/*.{woff,woff2,ttf,otf}',
        images: 'img/**/*.{png,jpg,jpeg,gif,svg,ico,json,xml}',
        js: 'js/**/*.js',
        sass: 'scss/**/*.scss',
        views: '**/*.{html,phtml,php,twig}'
    },
    dist: {
        dir: 'dist/',
        fonts: 'fonts',
        images: 'img',
        js: 'js',
        css: 'css'
    },
    options: {
        autoprefixer: {},
        browsersync: {
            open: false,
            notify: false,
            proxy: ''
        },
        csscomb: path.resolve(__dirname, '.csscomb.json'),
        cssnano: {
            preset: 'default'
        },
        hash: {
            hashLength: 20,
            template: '<%= name %>.<%= hash %><%= ext %>'
        },
        rucksack: {
            responsiveType: true,
            shorthandPosition: false,
            quantityQueries: false,
            inputPseudo: false,
            clearFix: false,
            fontPath: false,
            hexRGBA: false,
            easings: false,
            fallbacks: false,
            autoprefixer: false,
            reporter: false
        },
        sass: {
            includePaths: ['node_modules']
        },
        webpack: {
            // Generated by webpack task
        }
    }
};

function lynchburg(projectConfig) {
    const config = _merge({}, defaultConfig, projectConfig);

    // Set different flags based on command line arguments
    config.flags = {
        analyze: !!yargs.argv.analyze,
        debug: !!yargs.argv.debug,
        production: !!yargs.argv.production
    };

    // Build list of resolved paths to pass to tasks
    config.paths = {
        src: {},
        dist: {}
    };

    ['src', 'dist'].forEach(group => {
        Object.keys(config[group]).forEach(dirName => {
            if(dirName == 'dir' || dirName == 'views') {
                return;
            }
            config.paths[group][dirName] = path.resolve(config[group].dir, config[group][dirName])
        });
    });

    if(config.flags.debug) {
        debugLog('Lynchburg config');
        jsonLog(config);
    }

    const tasks = {};

    const clean = require('./tasks/clean.js');

    tasks.clean = clean(config.dist.dir);
    tasks.cleancss = clean(config.paths.dist.css);
    tasks.cleancss.displayName = 'cleancss';
    tasks.cleanjs = clean(config.paths.dist.js);
    tasks.cleanjs.displayName = 'cleanjs';

    tasks.csscomb = require('./tasks/csscomb.js')(config);
    tasks.fonts = require('./tasks/fonts.js')(config);
    tasks.images = require('./tasks/images.js')(config);
    tasks.reload = require('./tasks/reload.js')();
    tasks.sass = series(
        tasks.cleancss,
        require('./tasks/sass.js')(config)
    );
    tasks.webpack = series(
        tasks.cleanjs,
        require('./tasks/webpack.js')(config)
    );

    // Watchers are passed timed tasks to show output when watched task fires
    tasks.watch = cb => {
        watch(config.paths.src.fonts, tasks.fonts);

        watch(config.paths.src.images, tasks.images);

        watch(config.paths.src.js, series(
            tasks.webpack,
            tasks.reload
        ));


        // Watch Queue turned off to avoid infinite that could be caused by csscomb when it updates sass files
        const sassWatcher = watch(config.paths.src.sass, {queue: false}, series(
            tasks.csscomb,
            tasks.sass
        ));

        watch(config.src.views, tasks.reload);
    }
    tasks.watch.displayName = 'watch';

    tasks.serve = cb => {
        browserSync.init(config.options.browsersync);
    }
    tasks.serve.displayName = 'serve';

    tasks.build = series(
        tasks.clean,
        parallel(
            tasks.fonts,
            tasks.images,
            series(
                tasks.csscomb,
                tasks.sass
            ),
            tasks.webpack
        )
    );

    tasks.default = series(tasks.build, parallel(tasks.serve, tasks.watch));

    // Generate documentation for each task for `gulp --tasks`
    Object.keys(tasks).forEach(taskName => {
        generateDocumentation(tasks[taskName], taskName);
    });

    return tasks;
};

module.exports = lynchburg;
